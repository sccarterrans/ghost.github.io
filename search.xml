<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ArrayList与LinkedList</title>
      <link href="/ArrayList%E4%B8%8ELinkedList/"/>
      <url>/ArrayList%E4%B8%8ELinkedList/</url>
      
        <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>以下是数组在内存中存储结构和扩容过程。</p><p>array数组长度为4，现在需要放入第五个值，需要先扩容，在后边找到能容下新数组长度的连续空间</p><a id="more"></a><p><img src="2.1.png" alt></p><ul><li><p>新增数据空间判断</p><p>新增数据的时候需要判断当前是否有空闲空间存储数据</p></li><li><p>扩容需要申请新的连续空闲空间</p><p>上图为例，长度4需要扩容到8。必须找到长度为8的连续空间才能新建扩容数组</p></li><li><p>把老的数组复制过去，追加新的内容</p></li><li><p>回收老的数组空间</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><img src="2.2.png" alt></p><ul><li>寻找一个元素空间插入即可，不需要连续空间</li><li>链表长度大小不定</li><li>需要寻址，节省空间</li></ul><h3 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h3><p><img src="3.png" alt></p><ul><li><p>O(1)就是最低的时空复杂度了，耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 <strong>哈希算法就是典型的O(1)时间复杂度</strong>，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</p></li><li><p>O(N)就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法，就是O(n)；</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ArrayList是由数组组成，大小固定，不适合动态存储，LinkedList由双向列表组成，大小可变，扩展性强；ArrayList扩容大小为1.5倍(newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1))</li><li>ArrayList查询和修改方便，只需要修改和获取指定的数组值，LinkedList新增和删除方便，因为只需要添加和删除节点</li><li>数据结构都是存储在内存中，一般初始化时指定大小都是2的倍数，计算机分配空间都是使用次幂去分配，好处是能减少碎片空间，ArrayList扩容时需要查询连续的空间，而LinkedList只需要查询到下一个空间即可</li><li>同样是O(N)次遍历，ArrayList快于LinkedList，因为CPU缓存一次读取多块，ArrayList获取空间块链是连续的，而Linked获取空间块链可能是跳跃的，获取下一个元素需要利用内存中的下标去查找，CPU缓存读取速度大于内存</li><li>forEach循环时删除元素会爆ConcurrentModificationException异常,要使用迭代器(Iterator),或者线程安全的集合,原因是java.util.ArrayList.Itr#checkForComodification方法中modCount != expectedModCount</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务注册中心 Eureka 架构深入解读（转载）</title>
      <link href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka-%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/"/>
      <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka-%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>微服务架构中最核心的部分是服务治理，服务治理最基础的组件是注册中心。随着微服务架构的发展，出现了很多微服务架构的解决方案，其中包括我们熟知的 Dubbo 和 Spring Cloud。</p><p>关于注册中心的解决方案，dubbo 支持了 Zookeeper、Redis、Multicast 和 Simple，官方推荐 Zookeeper。Spring Cloud 支持了 Zookeeper、Consul 和 Eureka，官方推荐 Eureka。</p><a id="more"></a><p>两者之所以推荐不同的实现方式，原因在于组件的特点以及适用场景不同。简单来说：</p><ul><li><p>ZK 的设计原则是 CP，即强一致性和分区容错性。他保证数据的强一致性，但舍弃了可用性，<strong>如果出现网络问题可能会影响 ZK 的选举，导致 ZK 注册中心的不可用</strong>。</p></li><li><p>Eureka 的设计原则是 AP，即可用性和分区容错性。他保证了注册中心的可用性，但舍弃了数据一致性，<strong>各节点上的数据有可能是不一致的（会最终一致）</strong>。</p><p>Eureka 采用纯 Java 实现，除实现了注册中心基本的服务注册和发现之外，极大的满足注册中心的可用性，即使只有一台服务可用，也可以保证注册中心的可用性。</p></li></ul><p>本文将聚焦到 Eureka 的内部实现原理，先从微服务架构的部署图介绍 Eureka 的总体架构，然后剖析服务信息的存储结构，最后探究跟服务生命周期相关的服务注册机制、服务续约机制、服务注销机制、服务剔除机制、服务获取机制、和服务同步机制。</p><h2 id="Eureka-总体架构"><a href="#Eureka-总体架构" class="headerlink" title="Eureka 总体架构"></a>Eureka 总体架构</h2><p>下面是 Eureka 注册中心部署在多个机房的架构图，这正是他高可用性的优势（Zookeeper 千万别这么部署）。</p><p><img src="1.png" alt></p><p>从组件功能看：</p><ul><li>黄色注册中心集群，分别部署在北京、天津、青岛机房；</li><li>红色服务提供者，分别部署北京和青岛机房；</li><li>淡绿色服务消费者，分别部署在北京和天津机房；</li></ul><p>从机房分布看：</p><ul><li>北京机房部署了注册中心、服务提供者和服务消费者；</li><li>天津机房部署了注册中心和服务消费者；</li><li>青岛机房部署了注册中心和服务提供者；</li></ul><h3 id="组件调用关系"><a href="#组件调用关系" class="headerlink" title="组件调用关系"></a>组件调用关系</h3><p><strong>服务提供者</strong></p><ol><li>启动后，向注册中心发起 register 请求，注册服务</li><li>在运行过程中，定时向注册中心发送 renew 心跳，证明“我还活着”。</li><li>停止服务提供者，向注册中心发起 cancel 请求，清空当前服务注册信息。</li></ol><p><strong>服务消费者</strong></p><ol><li>启动后，从注册中心拉取服务注册信息</li><li>在运行过程中，定时更新服务注册信息。</li><li>服务消费者发起远程调用：<br>a&gt; 服务消费者（北京）会从服务注册信息中选择同机房的服务提供者（北京），发起远程调用。只有同机房的服务提供者挂了才会选择其他机房的服务提供者（青岛）。<br>b&gt; 服务消费者（天津）因为同机房内没有服务提供者，则会按负载均衡算法选择北京或青岛的服务提供者，发起远程调用。</li></ol><p><strong>注册中心</strong></p><ol><li><p>启动后，从其他节点拉取服务注册信息。</p></li><li><p>运行过程中，定时运行 evict 任务，剔除没有按时 renew 的服务（包括非正常停止和网络故障的服务）。</p></li><li><p>运行过程中，接收到的 register、renew、cancel 请求，都会同步至其他注册中心节点。</p><p>本文将详细说明上图中的 registry、register、renew、cancel、getRegistry、evict 的内部机制。</p></li></ol><h2 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h2><p>既然是服务注册中心，必然要存储服务的信息，我们知道 ZK 是将服务信息保存在树形节点上。而下面是 Eureka 的数据存储结构：</p><p><img src="2.png" alt></p><p>Eureka 的数据存储分了两层：数据存储层和缓存层。</p><p>Eureka Client 在拉取服务信息时，先从缓存层获取（相当于 Redis），如果获取不到，先把数据存储层的数据加载到缓存中（相当于 Mysql），再从缓存中获取。值得注意的是，数据存储层的数据结构是服务信息，而缓存中保存的是经过处理加工过的、可以直接传输到 Eureka Client 的数据结构。</p><p>Eureka 这样的数据结构设计是把内部的数据存储结构与对外的数据结构隔离开了，就像是我们平时在进行接口设计一样，对外输出的数据结构和数据库中的数据结构往往都是不一样的。</p><p><strong>数据存储层</strong></p><p>这里为什么说是存储层而不是持久层？因为 rigistry 本质上是一个双层的 ConcurrentHashMap，存储在内存中的。</p><ul><li><p>第一层的 key 是<code>spring.application.name</code>，value 是第二层 ConcurrentHashMap；</p></li><li><p>第二层 ConcurrentHashMap 的 key 是服务的 InstanceId，value 是 Lease 对象；</p></li><li><p>Lease 对象包含了服务详情和服务治理相关的属性。</p><p><strong>二级缓存层</strong></p></li></ul><p>Eureka 实现了二级缓存来保存即将要对外传输的服务信息，数据结构完全相同。</p><ul><li>一级缓存：<code>ConcurrentHashMap&lt;Key,Value&gt; readOnlyCacheMap</code>，本质上是 HashMap，无过期时间，保存服务信息的对外输出数据结构。</li><li>二级缓存：<code>Loading&lt;Key,Value&gt; readWriteCacheMap</code>，本质上是 guava 的缓存，包含失效机制，保存服务信息的对外输出数据结构。</li></ul><p>既然是缓存，那必然要有更新机制，来保证数据的一致性。下面是缓存的更新机制：</p><p><img src="3.png" alt></p><p>更新机制包含删除和加载两个部分，上图黑色箭头表示删除缓存的动作，绿色表示加载或触发加载的动作。</p><p><strong>删除二级缓存：</strong></p><ol><li>Eureka Client 发送 register、renew 和 cancel 请求并更新 registry 注册表之后，删除二级缓存；</li><li>Eureka Server 自身的 Evict Task 剔除服务后，删除二级缓存；</li><li>二级缓存本身设置了 guava 的失效机制，隔一段时间后自己自动失效；</li></ol><p><strong>加载二级缓存：</strong></p><ol><li>Eureka Client 发送 getRegistry 请求后，如果二级缓存中没有，就触发 guava 的 load，即从 registry 中获取原始服务信息后进行处理加工，再加载到二级缓存中。</li><li>Eureka Server 更新一级缓存的时候，如果二级缓存没有数据，也会触发 guava 的 load。</li></ol><p><strong>更新一级缓存：</strong></p><ol><li><p>Eureka Server 内置了一个 TimerTask，定时将二级缓存中的数据同步到一级缓存（这个动作包括了删除和加载）。</p><p>关于缓存的实现参考 ResponseCacheImpl</p></li></ol><h3 id="服务注册机制"><a href="#服务注册机制" class="headerlink" title="服务注册机制"></a>服务注册机制</h3><p>服务提供者、服务消费者、以及服务注册中心自己，启动后都会向注册中心注册服务（如果配置了注册）。下图是介绍如何完成服务注册的：</p><p><img src="4.png" alt></p><p>注册中心服务接收到 register 请求后：</p><ol><li>保存服务信息，将服务信息保存到 registry 中；</li><li>更新队列，将此事件添加到更新队列中，供 Eureka Client 增量同步服务信息使用。</li><li>清空二级缓存，即 readWriteCacheMap，用于保证数据的一致性。</li><li>更新阈值，供剔除服务使用。</li><li>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</li></ol><h3 id="服务续约机制"><a href="#服务续约机制" class="headerlink" title="服务续约机制"></a>服务续约机制</h3><p>服务注册后，要定时（默认 30S，可自己配置）向注册中心发送续约请求，告诉注册中心“我还活着”。</p><p><img src="5.png" alt></p><p>注册中心收到续约请求后：</p><ol><li><p>更新服务对象的最近续约时间，即 Lease 对象的 lastUpdateTimestamp;</p></li><li><p>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</p><p>剔除服务之前会先判断服务是否已经过期，判断服务是否过期的条件之一是续约时间和当前时间的差值是不是大于阈值。</p></li></ol><h3 id="服务注销机制"><a href="#服务注销机制" class="headerlink" title="服务注销机制"></a>服务注销机制</h3><p>服务<strong>正常停止</strong>之前会向注册中心发送注销请求，告诉注册中心“我要下线了”。</p><p><img src="6.png" alt></p><p>注册中心服务接收到 cancel 请求后：</p><ol><li><p>删除服务信息，将服务信息从 registry 中删除；</p></li><li><p>更新队列，将此事件添加到更新队列中，供 Eureka Client 增量同步服务信息使用。</p></li><li><p>清空二级缓存，即 readWriteCacheMap，用于保证数据的一致性。</p></li><li><p>更新阈值，供剔除服务使用。</p></li><li><p>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</p><p>服务正常停止才会发送 Cancel，如果是非正常停止，则不会发送，此服务由 Eureka Server 主动剔除。</p></li></ol><h3 id="服务剔除机制"><a href="#服务剔除机制" class="headerlink" title="服务剔除机制"></a>服务剔除机制</h3><p>Eureka Server 提供了服务剔除的机制，用于剔除没有正常下线的服务。</p><p><img src="7.png" alt></p><p>服务的剔除包括三个步骤，首先判断是否满足服务剔除的条件，然后找出过期的服务，最后执行剔除。</p><p><strong>判断是否满足服务剔除的条件</strong></p><p>有两种情况可以满足服务剔除的条件：</p><ol><li>关闭了自我保护</li><li>如果开启了自我保护，需要进一步判断是 Eureka Server 出了问题，还是 Eureka Client 出了问题，如果是 Eureka Client 出了问题则进行剔除。</li></ol><p>这里比较核心的条件是自我保护机制，Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。Eureka 的自我保护机制“谦虚”的认为如果大量服务都续约失败，则认为是自己出问题了（如自己断网了），也就不剔除了；反之，则是 Eureka Client 的问题，需要进行剔除。而<strong>自我保护阈值是区分 Eureka Client 还是 Eureka Server 出问题的临界值：如果超出阈值就表示大量服务可用，少量服务不可用，则判定是 Eureka Client 出了问题。如果未超出阈值就表示大量服务不可用，则判定是 Eureka Server 出了问题</strong>。</p><p>条件 1 中如果关闭了自我保护，则统统认为是 Eureka Client 的问题，把没按时续约的服务都剔除掉（这里有剔除的最大值限制）。</p><p>这里比较难理解的是阈值的计算：</p><ul><li>自我保护阈值 = 服务总数 * 每分钟续约数 * 自我保护阈值因子。</li><li>每分钟续约数 =（60S/ 客户端续约间隔）</li></ul><p>最后自我保护阈值的计算公式为：</p><p>自我保护阈值 = 服务总数 * （60S/ 客户端续约间隔） * 自我保护阈值因子。</p><p><strong>举例</strong>：如果有 100 个服务，续约间隔是 30S，自我保护阈值 0.85。</p><p>自我保护阈值 =100 * 60 / 30 * 0.85 = 170。</p><p>如果上一分钟的续约数 =180&gt;170，则说明大量服务可用，是服务问题，进入剔除流程；</p><p>如果上一分钟的续约数 =150&lt;170，则说明大量服务不可用，是注册中心自己的问题，进入自我保护模式，不进入剔除流程。</p><p><strong>找出过期的服务</strong></p><p>遍历所有的服务，判断上次续约时间距离当前时间大于阈值就标记为过期。并将这些过期的服务保存到集合中。</p><p><strong>剔除服务</strong></p><p>在剔除服务之前先计算剔除的数量，然后遍历过期服务，通过洗牌算法确保每次都公平的选择出要剔除的任务，最后进行剔除。</p><p>执行剔除服务后：</p><ol><li><p>删除服务信息，从 registry 中删除服务。</p></li><li><p>更新队列，将当前剔除事件保存到更新队列中。</p></li><li><p>清空二级缓存，保证数据的一致性。</p><p>实现过程参考 AbstractInstanceRegistry.evict() 方法。</p></li></ol><h3 id="服务获取机制"><a href="#服务获取机制" class="headerlink" title="服务获取机制"></a>服务获取机制</h3><p>Eureka Client 获取服务有两种方式，全量同步和增量同步。获取流程是根据 Eureka Server 的多层数据结构进行的：</p><p><img src="8.png" alt></p><p>无论是全量同步还是增量同步，都是先从缓存中获取，如果缓存中没有，则<strong>先加载到缓存中，再从缓存中获取。（registry 只保存数据结构，缓存中保存 ready 的服务信息。）</strong></p><ol><li>先从一级缓存中获取<br>a&gt; 先判断是否开启了一级缓存<br>b&gt; 如果开启了则从一级缓存中获取，如果存在则返回，如果没有，则从二级缓存中获取<br>d&gt; 如果未开启，则跳过一级缓存，从二级缓存中获取</li><li>再从二级缓存中获取<br>a&gt; 如果二级缓存中存在，则直接返回；<br>b&gt; 如果二级缓存中不存在，则先将数据加载到二级缓存中，再从二级缓存中获取。注意加载时需要判断是增量同步还是全量同步，增量同步从 recentlyChangedQueue 中 load，全量同步从 registry 中 load。</li></ol><h3 id="服务同步机制"><a href="#服务同步机制" class="headerlink" title="服务同步机制"></a>服务同步机制</h3><p>服务同步机制是用来同步 Eureka Server 节点之间服务信息的。它包括 Eureka Server 启动时的同步，和运行过程中的同步。</p><p><strong>启动时同步</strong></p><p><img src="9.png" alt></p><p>Eureka Server 启动后，遍历 eurekaClient.getApplications 获取服务信息，并将服务信息注册到自己的 registry 中。</p><p>注意这里是两层循环，第一层循环是为了保证已经拉取到服务信息，第二层循环是遍历拉取到的服务信息。</p><p><strong>运行过程中同步</strong></p><p><img src="10.png" alt></p><p>当 Eureka Server 节点有 register、renew、cancel 请求进来时，会将这个请求封装成 TaskHolder 放到 acceptorQueue 队列中，然后经过一系列的处理，放到 batchWorkQueue 中。</p><p><code>TaskExecutor.BatchWorkerRunnable</code>是个线程池，不断的从 batchWorkQueue 队列中 poll 出 TaskHolder，然后向其他 Eureka Server 节点发送同步请求。</p><p>这里省略了两个部分：</p><ul><li>一个是在 acceptorQueue 向 batchWorkQueue 转化时，省略了中间的 processingOrder 和 pendingTasks 过程。</li><li>另一个是当同步失败时，会将失败的 TaskHolder 保存到 reprocessQueue 中，重试处理。</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对微服务解决方案 Dubbo 和 Spring Cloud 的对比非常多，这里对注册中心做个简单对比。</p><p><img src="11.png" alt></p><table><thead><tr><th align="left"></th><th align="left">Zookeeper</th><th align="left">Eureka</th></tr></thead><tbody><tr><td align="left">设计原则</td><td align="left">CP</td><td align="left">AP</td></tr><tr><td align="left">优点</td><td align="left">数据强一致</td><td align="left">服务高可用</td></tr><tr><td align="left">缺点</td><td align="left">网络分区会影响 Leader 选举，超过阈值后集群不可用</td><td align="left">服务节点间的数据可能不一致； Client-Server 间的数据可能不一致；</td></tr><tr><td align="left">适用场景</td><td align="left">单机房集群，对数据一致性要求较高</td><td align="left">云机房集群，跨越多机房部署；对注册中心服务可用性要求较高</td></tr></tbody></table><p>[转载链接]</p><p><a href="https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh" target="_blank" rel="noopener">https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核空间和用户空间</title>
      <link href="/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
      <url>/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="Rings"><a href="#Rings" class="headerlink" title="Rings"></a>Rings</h3><p>在计算机科学中, <strong>分级保护域</strong>（英语：hierarchical protection domains），经常被叫作<strong>保护环</strong>（Protection Rings），又称<strong>环型保护</strong>（Rings Protection）、<strong>CPU环</strong>（CPU Rings），简称Rings。这是一种用来在发生故障时保护数据和功能，提升容错度，避免恶意操作 ，提升计算机安全的设计方式。</p><a id="more"></a><p>（来自维基百科）</p><p><img src="1.png" alt></p><p>工作在不同Ring中的对象对资源有不同的访问级别。Rings是从最高特权级（通常对应最小的数字）到最低特权级（最大的数字）排列的。在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），同时内层Ring可以随便使用外层Ring的资源。</p><ul><li>Ring 0用于内核代码和驱动程序</li><li>Ring 1-2用于设备驱动程序</li><li>Ring 3用于非特权代码（几乎所有的用户程序都在这一级别）</li></ul><p>​          Rings的概念最早出现于x 86保护模式的设计中。Intel的初衷是让驱动存在于此Ring 1-2，但现代操作系统通常将驱动也放在Ring 0上。</p><h3 id="内核空间（Kernel-space-）与用户空间（User-space-）"><a href="#内核空间（Kernel-space-）与用户空间（User-space-）" class="headerlink" title="内核空间（Kernel space ）与用户空间（User space ）"></a>内核空间（Kernel space ）与用户空间（User space ）</h3><p>Kernel space 是 Linux 内核的运行空间（Ring0），User space 是用户程序的运行空间（Ring3）。通过分环隔离实现了操作系统的稳定性及可用性，即使用户的程序崩溃了，内核也不受影响。</p><p>下面描述用户空间与内核空间交互情况（来自互联网）：</p><p><img src="2.png" alt></p><p>运行在Kernel space的进程拥有CPU环最高权限，可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（system call），才能向内核发出指令。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = "my string" // 用户空间</span><br><span class="line">x = x + 2</span><br><span class="line">file.write(str) // 切换到内核空间</span><br><span class="line"></span><br><span class="line">y = x + 4 // 切换回用户空间</span><br></pre></td></tr></table></figure><p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p><h3 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h3><p>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为<strong>内核空间</strong>。而较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为<strong>用户空间</strong>。当进程运行在Ring0级别时被称为运行在<strong>内核态</strong>，而运行在Ring3级别时被称为<strong>用户态</strong>。</p><p>下面描述了每个进程寻址空间的分配情况（来自互联网）:</p><p><img src="3.png" alt></p><p><font color="#FF0000"><strong>内核空间是所有进程共享，用户空间是当前进程独享</strong></font></p><p>内核空间中存放的是<strong>内核代码</strong>和<strong>数据</strong>，而进程的用户空间中存放的是<strong>用户程序的代码</strong>和<strong>数据</strong>。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>通过用户空间和内核空间的角度看一看Linux系统的架构(此图来自互联网)：</p><p><img src="4.png" alt></p><ul><li><p>当用户空间运行进程需要使用硬件资源或设备驱动时，通过调用内核空间暴露的接口（System Call）来申请资源或写入内核空间的高速页缓存</p></li><li><p>内核空间进程会实时调用（fsync）或由操作系统统一调度flusher内核线程将（write）数据同步到磁盘</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以Mysql为例：</span><br><span class="line">innodb_flush_log_at_trx_commit 1 (fsync)</span><br><span class="line">事务提交时，进程会将数据写入用户空间应用缓存,同时掉用系统提供fsync函数将用户空间缓存的数据写入磁盘</span><br><span class="line">innodb_flush_log_at_trx_commit 2 (write)</span><br><span class="line">事务提交时，进程会调用systemCall函数将用户空间应用缓存数据通过dma的方式copy到内核空间高速页缓存,等待flusher内核线程将数据写入磁盘</span><br></pre></td></tr></table></figure><p>从架构图可以看出内核空间进程可以操作设备程序（网卡程序、显卡程序）和硬件设备（键盘、鼠标、音箱）</p></li></ul><p>[参考链接]</p><ul><li><a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/8410350.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
