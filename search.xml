<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux内核空间和用户空间</title>
      <link href="/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
      <url>/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="Rings"><a href="#Rings" class="headerlink" title="Rings"></a>Rings</h3><p>在计算机科学中, <strong>分级保护域</strong>（英语：hierarchical protection domains），经常被叫作<strong>保护环</strong>（Protection Rings），又称<strong>环型保护</strong>（Rings Protection）、<strong>CPU环</strong>（CPU Rings），简称Rings。这是一种用来在发生故障时保护数据和功能，提升容错度，避免恶意操作 ，提升计算机安全的设计方式。</p><a id="more"></a><p>（来自维基百科）</p><p><img src="1.png" alt></p><p>工作在不同Ring中的对象对资源有不同的访问级别。Rings是从最高特权级（通常对应最小的数字）到最低特权级（最大的数字）排列的。在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），同时内层Ring可以随便使用外层Ring的资源。</p><ul><li>Ring 0用于内核代码和驱动程序</li><li>Ring 1-2用于设备驱动程序</li><li>Ring 3用于非特权代码（几乎所有的用户程序都在这一级别）</li></ul><p>​          Rings的概念最早出现于x 86保护模式的设计中。Intel的初衷是让驱动存在于此Ring 1-2，但现代操作系统通常将驱动也放在Ring 0上。</p><h3 id="内核空间（Kernel-space-）与用户空间（User-space-）"><a href="#内核空间（Kernel-space-）与用户空间（User-space-）" class="headerlink" title="内核空间（Kernel space ）与用户空间（User space ）"></a>内核空间（Kernel space ）与用户空间（User space ）</h3><p>Kernel space 是 Linux 内核的运行空间（Ring0），User space 是用户程序的运行空间（Ring3）。通过分环隔离实现了操作系统的稳定性及可用性，即使用户的程序崩溃了，内核也不受影响。</p><p>下面描述用户空间与内核空间交互情况（来自互联网）：</p><p><img src="2.png" alt></p><p>运行在Kernel space的进程拥有CPU环最高权限，可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（system call），才能向内核发出指令。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = "my string" // 用户空间</span><br><span class="line">x = x + 2</span><br><span class="line">file.write(str) // 切换到内核空间</span><br><span class="line"></span><br><span class="line">y = x + 4 // 切换回用户空间</span><br></pre></td></tr></table></figure><p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p><h3 id="内核空间（Kernel-space）与用户空间（User-space）空间分配"><a href="#内核空间（Kernel-space）与用户空间（User-space）空间分配" class="headerlink" title="内核空间（Kernel space）与用户空间（User space）空间分配"></a>内核空间（Kernel space）与用户空间（User space）空间分配</h3><p>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为<strong>内核空间</strong>。而较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为<strong>用户空间</strong>。当进程运行在Ring0级别时被称为运行在<strong>内核态</strong>，而运行在Ring3级别时被称为<strong>用户态</strong>。</p><p>下面描述了每个进程寻址空间的分配情况（来自互联网）:</p><p><img src="3.png" alt></p><p><font color="#FF0000"><strong>内核空间是所有进程共享，用户空间是当前进程独享</strong></font></p><p>内核空间中存放的是<strong>内核代码</strong>和<strong>数据</strong>，而进程的用户空间中存放的是<strong>用户程序的代码</strong>和<strong>数据</strong>。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>通过用户空间和内核空间的角度看一看Linux系统的架构(此图来自互联网)：</p><p><img src="4.png" alt></p><ul><li><p>当用户空间运行进程需要使用硬件资源或设备驱动时，通过调用内核空间暴露的接口（System Call）来申请资源或写入内核空间的高速页缓存</p></li><li><p>内核空间进程会实时调用（fsync）或由操作系统统一调度flusher内核线程将（write）数据同步到磁盘</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以Mysql为例：</span><br><span class="line">innodb_flush_log_at_trx_commit 1 (fsync)</span><br><span class="line">事务提交时，进程会从用户空间应用缓存把数据copy到内核空间高速页缓存，并同时调用系统提供sync函数将数据写入磁盘</span><br><span class="line">innodb_flush_log_at_trx_commit 2 (write)</span><br><span class="line">事务提交时，进程会从用户空间应用缓存把数据copy到内核空间高速页缓存，等待flusher内核线程将数据写入磁盘</span><br></pre></td></tr></table></figure><p>从架构图可以看出内核空间进程可以操作设备程序（网卡程序、显卡程序）和硬件设备（键盘、鼠标、音箱）</p></li></ul><p>[参考链接]</p><ul><li><a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/8410350.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/eureka/"/>
      <url>/eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务注册中心-Eureka"><a href="#微服务注册中心-Eureka" class="headerlink" title="微服务注册中心 Eureka"></a>微服务注册中心 Eureka</h1><p>微服务架构中最核心的部分是服务治理，服务治理中最基础的组件是注册中心。Spring Cloud支持Zookeeper、Consul和Eureka，官方推荐Eureka。</p><p>两者组件的特点以及使用场景不同。简单来说：</p><ul><li>Zookeeper的设计原则是CP，即强一致性和分区容错性。他保证数据的强一致性（Consistency），但舍弃了可用性（Availability），<strong>如果出现网络问题可能会影响 ZK 的选举，导致 ZK 注册中心的不可用</strong>。</li><li>Eureka 的设计原则是 AP，即可用性（Availability）和分区容错性（Partition Tolerance）。他保证了注册中心的可用性，但舍弃了数据一致性，<strong>各节点上的数据有可能是不一致的（会最终一致）</strong>。</li></ul><p>本文将聚焦到 Eureka 的内部实现原理，先从微服务架构的部署图介绍 Eureka 的总体架构，然后剖析服务信息的存储结构，最后探究跟服务生命周期相关的服务注册机制、服务续约机制、服务注销机制、服务剔除机制、服务获取机制、和服务同步机制。</p><h2 id="Eureka-总体架构"><a href="#Eureka-总体架构" class="headerlink" title="Eureka 总体架构"></a>Eureka 总体架构</h2><p>下面是 Eureka 注册中心部署在多个机房的架构图，这正是他高可用性的优势（Zookeeper 千万别这么部署）。</p><p><img src="D:%5Cwork%5Chexo%5Csccarterrans.github.io%5Csource_posts%5Ceureka%5Ceureka%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt></p><p>从组件功能看：</p><ul><li>黄色注册中心集群，分别部署在北京、上海、深圳机房；</li><li>红色服务提供者，分别部署北京和上海机房；</li><li>淡绿色服务消费者，分别部署在北京和上海机房；</li></ul><p>从机房分布看：</p><ul><li>北京机房部署了注册中心、服务提供者和服务消费者；</li><li>上海机房部署了注册中心和服务消费者；</li><li>深圳机房部署了注册中心和服务提供者；</li></ul><h3 id="组件调用关系"><a href="#组件调用关系" class="headerlink" title="组件调用关系"></a>组件调用关系</h3><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a><strong>服务提供者</strong></h4><ol><li>启动后，向注册中心发起 register 请求，注册服务</li><li>在运行过程中，定时向注册中心发送 renew 心跳，证明“我还活着”。</li><li>停止服务提供者，向注册中心发起 cancel 请求，清空当前服务注册信息。</li></ol><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a><strong>服务消费者</strong></h4><ol><li>启动后，从注册中心拉取服务注册信息。</li><li>在运行过程中，定时更新服务注册信息，默认30秒刷新一次。</li><li>服务消费者发起远程调用：<br>a&gt; 服务消费者（北京）会从服务注册信息中选择同机房的服务提供者（北京），发起远程调用。只有同机房的服务提供者挂了才会选择其他机房的服务提供者（深圳）。<br>b&gt; 服务消费者（上海）因为同机房内没有服务提供者，则会按负载均衡算法选择北京或深圳的服务提供者，发起远程调用。</li></ol><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a><strong>注册中心</strong></h4><ol><li><p>启动后，从其他节点拉取服务注册信息。</p></li><li><p>运行过程中，定时运行 evict 任务，剔除没有按时 renew 的服务（包括非正常停止和网络故障的服务）。</p></li><li><p>运行过程中，接收到的 register、renew、cancel 请求，都会同步至其他注册中心节点（非开启自我保护的节点）。</p><p>本文将详细说明上图中的 registry、register、renew、cancel、getRegistry、evict 的内部机制。</p></li></ol><h2 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h2><p>ZK 服务信息保存在树形节点上，Eureka则保存在双层的 ConcurrentHashMap中，存储在内存中的。</p><p>link：<a href="https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh" target="_blank" rel="noopener">https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
