<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO模型</title>
      <link href="/IO%E6%A8%A1%E5%9E%8B/"/>
      <url>/IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="PIO与DMA"><a href="#PIO与DMA" class="headerlink" title="PIO与DMA"></a>PIO与DMA</h1><p>在介绍 I/O 模型之前，有必要简单地说说慢速 I/O 设备和内存之间的数据传输方式。</p><ul><li>PIO的英文拼写是“Programming Input/Output Model”，PIO模式是一种通过CPU执行I/O端口指令来进行数据的读写的数据交换模式。是最早先的硬盘数据传输模式，数据传输速率低下，CPU占有率也很高，大量传输数据时会因为占用过多的CPU资源而导致系统停顿，无法进行其它的操作。</li><li>DMA的英文拼写是“Direct Memory Access”，汉语的意思就是直接内存访问，是一种不经过CPU而直接从内存了存取数据的数据交换模式。PIO模式下硬盘和内存之间的数据传输是由CPU来控制的；而在DMA模式下，CPU只须向DMA控制器下达指令，让DMA控制器来处理数的传送，数据传送完毕再把信息反馈给CPU，这样就很大程度上减轻了CPU资源占有率。</li></ul><a id="more"></a><h1 id="缓存IO和直接IO"><a href="#缓存IO和直接IO" class="headerlink" title="缓存IO和直接IO"></a>缓存IO和直接IO</h1><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存IO：数据从磁盘先通过DMA模式拷贝到内核空间高速缓存页,再从高速缓存页通过cpu拷贝到用户空间应用缓存</span><br><span class="line">直接IO：数据从磁盘通过DMA模式拷贝到用户空间应用缓存</span><br></pre></td></tr></table></figure><h2 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h2><p><img src="1.png" alt="缓存I/O"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存I/O被称作为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O</span><br></pre></td></tr></table></figure><ul><li>读操作：</li></ul><p>操作系统检查内核空间的高速缓存页是否命中，如果命中直接返回；否则从物理磁盘中读取，然后load到内核缓存中。</p><ul><li>写操作：</li></ul><p>​        进程调用SystemCall函数将用户空间应用缓存数据通过DMA的方式拷贝到内核空间高速页缓存；</p><ol><li>update系统守护进程会周期性地（一般每隔30秒）调用sync函数，定期冲洗内核块缓冲区数据写入磁盘。</li><li>同时调用系统提供<strong>write</strong>函数立刻返回，等待flusher内核线程空闲时将数据写入磁盘。</li><li>进程调用systemCall函数将用户空间应用缓存数据通过dma的方式拷贝到内核空间高速页缓存,同时掉用系统提供<strong>fsync</strong>函数将用户空间缓存的数据写入磁盘。</li></ol><ul><li>缓存I/O的优点：</li></ul><ol><li>分离了内核空间和用户空间，保护系统本身的运行安全，避免应用程序异常导致系统崩溃&lt;<a href="https://sccarterrans.github.io/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/">Linux内核空间和用户空间</a>&gt;</li><li>减少缓存与磁盘的I/O磁盘,提升数据读取和写入的性能</li></ol><ul><li>缓存I/O的缺点：</li></ul><ol><li>数据传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些拷贝操作会给CPU以及内存带来一定的开销。</li></ol><h2 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区,自己管理I/O缓存区，这样做的目</span><br><span class="line">的是减少一次从内核缓冲区到用户程序缓存的数据复制,Linux系统提供open()函数在调用时增加O_DIRECT参数选项，用它打开的文件便可以绕过内核缓冲区完成直接访问，这样便有效避免了CPU和内存的多余时间开销</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="直接I/O"></p><ul><li>引入内核缓冲区的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在内核缓冲区中，那么就不需要再次访问磁盘；而当进程需要向文件中写入数据时，实际上只是写到了内核缓冲区便告诉进程已经写成功，而真正写入磁盘是通过一定的策略进行延迟的。然而，对于一些较复杂的应用，比如数据库服务器，它们为了充分提高性能，希望绕过内核缓冲区，由自己在用户态空间实现并管理I/O缓冲区，包括缓存机制和写延迟机制等，以支持独特的查询机制，比如数据库可以根据更加合理的策略来提高查询缓存命中率。另一方面，绕过内核缓冲区也可以减少系统内存的开销，因为内核缓冲区本身就在使用系统内存。</li><li>应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。<br>直接I/O的缺点就是如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。通常直接I/O跟异步I/O结合使用会得到较好的性能。</li></ul><p>PIO 我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘<br>文件到内存中，数据要经过CPU存储转发，这种方式称为PIO。显然这种方式非常不合理，需要占用大量的CPU时间来读取文件，造成文件访问时系统几乎停止响应。</p><p>DMA 后来，DMA（直接内存访问，Direct Memory Access）取代了PIO，它可以不经过CPU而直接进行磁盘<br>和内存（内核空间）的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异其实并不十分明显，因为这主要取决于慢速设备的速度。</p><p>可以肯定的是，PIO模式的计算机我们现在已经很少见到了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之explain</title>
      <link href="/MySQL%E4%B9%8Bexplain/"/>
      <url>/MySQL%E4%B9%8Bexplain/</url>
      
        <content type="html"><![CDATA[<h1 id="分享主题"><a href="#分享主题" class="headerlink" title="分享主题"></a>分享主题</h1><p>mysql explain查询计划</p><h2 id="分享目标"><a href="#分享目标" class="headerlink" title="分享目标"></a>分享目标</h2><ol><li>掌握最左前缀原则</li><li>掌握explain查询计划显示索引是否被使用到</li><li>掌握如何正确使用索引，才不会引起索引失效</li></ol><h2 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句的执行计划进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.使用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。可以通过explain命令深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><a id="more"></a><p>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 explain 就可以了, 例如:</p><p><img src="1.png" alt></p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>expain出来的信息有10列，分别是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id: SELECT查询的标识符，每个SELECT都会自动分配一个唯一的标识符</span><br><span class="line">select_type: SELECT查询的类型</span><br><span class="line">table: 查询的是哪张表</span><br><span class="line">type: join类型</span><br><span class="line">possible_keys:此次查询中可能选用的索引</span><br><span class="line">key: 此次查询中确切使用到的索引</span><br><span class="line">key_len: 此次查询中使用到索引的长度</span><br><span class="line">ref: 哪个字段或常数与key一起被使用</span><br><span class="line">rows: 显示此次查询一共扫描多少行。这是一个估计值</span><br><span class="line">Extra: 额外信息</span><br></pre></td></tr></table></figure><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3><p>新建user表, 添加组合索引idx_name_age和单列索引idx_sex，案例mysql版本是5.7版本；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name_age`</span> (<span class="string">`name`</span>,<span class="string">`age`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_sex`</span> (<span class="string">`sex`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`sex`</span>, <span class="string">`address`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'zhangsan'</span>, <span class="string">'20'</span>, <span class="string">'0'</span>, <span class="string">'中信广场'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`sex`</span>, <span class="string">`address`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'lisi'</span>, <span class="string">'20'</span>, <span class="string">'0'</span>, <span class="string">'中信广场'</span>);</span><br></pre></td></tr></table></figure><h4 id="select-type（重要）"><a href="#select-type（重要）" class="headerlink" title="select_type（重要）"></a>select_type（重要）</h4><p>查询类型，主要用于区别普通查询、联合查询(union、union all)、子查询等复杂查询。</p><h6 id="simple：-简单SELECT-不使用UNION或子查询"><a href="#simple：-简单SELECT-不使用UNION或子查询" class="headerlink" title="simple： 简单SELECT(不使用UNION或子查询)"></a>simple： 简单SELECT(不使用UNION或子查询)</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select *from user;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="primary：最外面的SELECT"><a href="#primary：最外面的SELECT" class="headerlink" title="primary：最外面的SELECT"></a>primary：最外面的SELECT</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select(select name from user) from user;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | PRIMARY     | user  | index | NULL          | idx_sex      | 4       | NULL |    2 | Using index |</span><br><span class="line">|  2 | SUBQUERY    | user  | index | NULL          | idx_name_age | 308     | NULL |    2 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery"><a href="#subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery" class="headerlink" title="subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery"></a>subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select *from user where id=(select max(id) from user);</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+------------------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra                        |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+------------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | user  | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL                         |</span><br><span class="line">|  2 | SUBQUERY    | NULL  | NULL  | NULL          | NULL    | NULL    | NULL  | NULL | <span class="keyword">Select</span> <span class="keyword">tables</span> optimized away |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">依次从好到差:</span><br><span class="line">system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，</span><br><span class="line">index_merge，index，ALL</span><br></pre></td></tr></table></figure><p>除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引,最少要索引使用到range级别</p><h6 id="system"><a href="#system" class="headerlink" title="system"></a>system</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表中只有一行数据或者是空表</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select *from (select *from user where id=1) a;</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 | NULL  |</span><br><span class="line">|  2 | DERIVED     | user       | const  | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="const（重要）"><a href="#const（重要）" class="headerlink" title="const（重要）"></a>const（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select *from user where id=1;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="eq-ref（重要）"><a href="#eq-ref（重要）" class="headerlink" title="eq_ref（重要）"></a>eq_ref（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">连接字段主键或者唯一性索引。</span><br><span class="line">此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 '=', 查询效率较高.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select a.id from user a left join user b on a.id=b.id;</span><br><span class="line">+<span class="comment">----+-------------+-------+--------+---------------+---------+---------+-------------------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref               | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+--------+---------------+---------+---------+-------------------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | a     | index  | NULL          | idx_sex | 4       | NULL              |    2 | Using index |</span><br><span class="line">|  1 | SIMPLE      | b     | eq_ref | PRIMARY       | PRIMARY | 4       | fcp_kkb_demo.a.id |    1 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+--------+---------------+---------+---------+-------------------+------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h6 id="ref（重要）"><a href="#ref（重要）" class="headerlink" title="ref（重要）"></a>ref（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对非唯一性索引，使用等值（=）查询非主键。或者是使用了最左前缀规则索引的查询。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--非唯一索引</span></span><br><span class="line">mysql&gt; explain select a.id from user a left join user b on a.name=b.name;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+---------------------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref                 | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+---------------------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | a     | index | NULL          | idx_name_age | 308     | NULL                |    2 | Using index |</span><br><span class="line">|  1 | SIMPLE      | b     | ref   | idx_name_age  | idx_name_age | 303     | fcp_kkb_demo.a.name |    1 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+---------------------+------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--最左前缀</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'zhangsan'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 303     | const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">思考：<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> sex = <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure><h6 id="range（重要）"><a href="#range（重要）" class="headerlink" title="range（重要）"></a>range（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where id &gt;1;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | range | PRIMARY       | PRIMARY | 4       | NULL |    1 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--like前缀索引</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'z%'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | range | idx_name_age  | idx_name_age | 303     | NULL |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--索引覆盖</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%san'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | NULL          | idx_name_age | 308     | NULL |    2 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="all（重要）"><a href="#all（重要）" class="headerlink" title="all（重要）"></a>all（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个就是全表扫描数据文件，然后再在**server**层进行过滤返回符合要求的记录。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="extra（重要）"><a href="#extra（重要）" class="headerlink" title="extra（重要）"></a>extra（重要）</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这个列包含不适合在其他列中显示单十分重要的额外的信息，这个列可以显示的信息非常多，有几十种，常用的有</span><br><span class="line">distinct：在select部分使用了distinct关键字</span><br><span class="line">no tables used：不带from字句的查询或者From dual查询</span><br><span class="line">使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接</span><br><span class="line">即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</span><br><span class="line">using filesort（重要）：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</span><br><span class="line">using index（重要）：查询时不需要回表查询，直接通过索引就可以获取查询的数据</span><br><span class="line">using where（重要）：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</span><br></pre></td></tr></table></figure><h6 id="using-filesort"><a href="#using-filesort" class="headerlink" title="using filesort"></a>using filesort</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user order by address;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--order by id</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | NULL          | PRIMARY | 4       | NULL |    2 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="using-index（重要）"><a href="#using-index（重要）" class="headerlink" title="using index（重要）"></a>using index（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表示相应的SELECT查询中使用到了覆盖索引（Covering Index），避免访问表的数据行，效率不错</span><br><span class="line">如果同时出现Using Where ，说明索引被用来执行查找索引键值</span><br><span class="line">如果没有同时出现Using Where ，表明索引用来读取数据而非执行查找动作</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--全值匹配 覆盖索引</span></span><br><span class="line">mysql&gt; explain select name,age from user;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | NULL          | idx_name_age | 308     | NULL |    2 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--索引参与查找</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zhangsan'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref   | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 303     | const |    1 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h6 id="using-where（重要）"><a href="#using-where（重要）" class="headerlink" title="using where（重要）"></a>using where（重要）</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根</span><br><span class="line">据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎</span><br><span class="line">层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显</span><br><span class="line">示using index condition</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--无索引查询</span></span><br><span class="line">mysql&gt; explain select name,age from user where address='zhangsan';</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--索引失效</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> *<span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age=<span class="number">18</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">--索引下推</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zhangsan'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 303     | const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zhangsan'</span> <span class="keyword">and</span> age=<span class="number">20</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref         | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 308     | const,const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zhangsan'</span> <span class="keyword">and</span> age=<span class="number">20</span> <span class="keyword">and</span> address=<span class="string">'中信广场'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+------------------------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref         | rows | Extra                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 308     | const,const |    1 | Using index condition; Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.全值匹配我最爱</span><br><span class="line">2.最佳左前缀法则</span><br><span class="line">3.不要在索引上做计算</span><br><span class="line">4.范围条件右边的列失效</span><br><span class="line">5.尽量使用覆盖索引</span><br><span class="line">6.索引字段上不要使用不等</span><br><span class="line">7.主键索引字段上不可以判断null</span><br><span class="line">8.索引字段使用like不以通配符开头</span><br><span class="line">9.索引字段字符串要加单引号</span><br><span class="line">10.索引字段不要使用or</span><br></pre></td></tr></table></figure><h3 id="全值匹配我最爱"><a href="#全值匹配我最爱" class="headerlink" title="全值匹配我最爱"></a>全值匹配我最爱</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name='zhangsan' and age=20;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref         | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 308     | const,const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组合索引，带头索引不能死，中间索引不能断</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--错误示例</span></span><br><span class="line">mysql&gt; explain select * from user where  age=20;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="不要在索引上做计算"><a href="#不要在索引上做计算" class="headerlink" title="不要在索引上做计算"></a>不要在索引上做计算</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要进行这些操作：计算、函数、自动/手动类型转换，不然会导致索引失效而转向全表扫描</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name='zhangsan';</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 303     | const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">--错误示例</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">left</span> (<span class="keyword">name</span>,<span class="number">1</span>)=<span class="string">'zhangsan'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="范围条件右边的列失效"><a href="#范围条件右边的列失效" class="headerlink" title="范围条件右边的列失效"></a>范围条件右边的列失效</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name='zhangsan' and age&gt;20;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | range | idx_name_age  | idx_name_age | 308     | NULL |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="尽量使用覆盖索引"><a href="#尽量使用覆盖索引" class="headerlink" title="尽量使用覆盖索引"></a>尽量使用覆盖索引</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽量使用覆盖索引（只查询索引的列），也就是索引列和查询列一致，减少select *</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | NULL          | idx_name_age | 308     | NULL |    2 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | NULL          | idx_name_age | 308     | NULL |    2 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="索引字段上不要使用不等"><a href="#索引字段上不要使用不等" class="headerlink" title="索引字段上不要使用不等"></a>索引字段上不要使用不等</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name!='zhangsan';</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | idx_name_age  | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>&lt;&gt;<span class="string">'zhangsan'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | idx_name_age  | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="主键索引字段上不可以判断null"><a href="#主键索引字段上不可以判断null" class="headerlink" title="主键索引字段上不可以判断null"></a>主键索引字段上不可以判断null</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键字段上不可以使用 null</span><br><span class="line">索引字段上使用 is null / is not null 判断时，可使用索引</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--非主键索引</span></span><br><span class="line">mysql&gt; explain select * from user where name is null;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key          | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ref  | idx_name_age  | idx_name_age | 303     | const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+--------------+---------+-------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | range | idx_name_age  | idx_name_age | 303     | NULL |    2 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">--主键索引</span></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | PRIMARY       | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="索引字段使用like不以通配符开头"><a href="#索引字段使用like不以通配符开头" class="headerlink" title="索引字段使用like不以通配符开头"></a>索引字段使用like不以通配符开头</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name like '%san';</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'zhang%'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | range | idx_name_age  | idx_name_age | 303     | NULL |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'zhang%'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | idx_name_age  | idx_name_age | 308     | NULL |    2 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%san'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | index | NULL          | idx_name_age | 308     | NULL |    2 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="索引字段字符串要加单引号"><a href="#索引字段字符串要加单引号" class="headerlink" title="索引字段字符串要加单引号"></a>索引字段字符串要加单引号</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name=123;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | idx_name_age  | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="索引字段不要使用or"><a href="#索引字段不要使用or" class="headerlink" title="索引字段不要使用or"></a>索引字段不要使用or</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引使用or会导致索引失效，全表扫描</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where name='zhangsan' or age=20;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | user  | ALL  | idx_name_age  | NULL | NULL    | NULL |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全值匹配我最爱，最左前缀要遵守 </span><br><span class="line">带头大哥不能死，中间兄弟不能断 </span><br><span class="line">索引列上少计算，范围之后全失效 </span><br><span class="line">LIKE符号写最右，覆盖索引不写星 </span><br><span class="line">不等空值还有or，索引失效要少用</span><br></pre></td></tr></table></figure><fron><p><br><br></p></fron><p></p><p>[参考链接]</p><ul><li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008131735</a></li><li><a href="https://blog.csdn.net/rewiner120/article/details/70598797" target="_blank" rel="noopener">https://blog.csdn.net/rewiner120/article/details/70598797</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> explain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引之谜</title>
      <link href="/MySQL%E7%B4%A2%E5%BC%95%E4%B9%8B%E8%B0%9C/"/>
      <url>/MySQL%E7%B4%A2%E5%BC%95%E4%B9%8B%E8%B0%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="分享主题"><a href="#分享主题" class="headerlink" title="分享主题"></a>分享主题</h1><p>MSQL架构、索引介绍及原理</p><h1 id="分享目标"><a href="#分享目标" class="headerlink" title="分享目标"></a>分享目标</h1><ol><li>理解MySQL架构组件及功能</li><li>理解MySQL执行流程</li><li>掌握MySQL中的表数据和索引在底层是如何被存储</li><li>掌握聚集索引（IOT索引组织表）和非聚集索引（堆组织表）的存储方式</li><li>掌握索引覆盖和回表概念</li></ol><a id="more"></a><h1 id="MySQL架构篇"><a href="#MySQL架构篇" class="headerlink" title="MySQL架构篇"></a>MySQL架构篇</h1><p><img src="1.jpg" alt="Mysql架构"></p><h2 id="Connectors"><a href="#Connectors" class="headerlink" title="Connectors"></a>Connectors</h2><p>连接器，指的是不同语言中与SQL的交互</p><h2 id="Management-Serveices-amp-Utilities"><a href="#Management-Serveices-amp-Utilities" class="headerlink" title="Management Serveices &amp; Utilities"></a>Management Serveices &amp; Utilities</h2><p>系统管理和控制工具</p><h2 id="Connection-Pool-连接池"><a href="#Connection-Pool-连接池" class="headerlink" title="Connection Pool: 连接池"></a>Connection Pool: 连接池</h2><ul><li>管理缓冲用户连接，线程处理等需要缓存的需求。</li><li>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。</li><li>而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。</li></ul><h2 id="SQL-Interface-SQL接口"><a href="#SQL-Interface-SQL接口" class="headerlink" title="SQL Interface: SQL接口"></a>SQL Interface: SQL接口</h2><p>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</p><h2 id="Parser-解析器"><a href="#Parser-解析器" class="headerlink" title="Parser: 解析器"></a>Parser: 解析器</h2><p>SQL命令传递到解析器的时候会被解析器验证和解析。</p><p>主要功能：</p><ul><li>将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，SQL语句的传递和处理就是基于这个结构的。</li><li>如果在分解过程中遇到错误，那么就说明这个sql语句是不合理的。</li></ul><h2 id="Optimizer-查询优化器"><a href="#Optimizer-查询优化器" class="headerlink" title="Optimizer: 查询优化器"></a>Optimizer: 查询优化器</h2><p>SQL语句在查询之前会使用查询优化器对查询进行优化。explain语句查看的SQL语句执行计划，就是由查询优化器生成的。</p><h2 id="Cache和Buffer：-查询缓存"><a href="#Cache和Buffer：-查询缓存" class="headerlink" title="Cache和Buffer： 查询缓存"></a>Cache和Buffer： 查询缓存</h2><p>他的主要功能是将客户端提交给MySQL的 select请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。<br>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p><h2 id="Pluggable-Storage-Engines：存储引擎"><a href="#Pluggable-Storage-Engines：存储引擎" class="headerlink" title="Pluggable Storage Engines：存储引擎"></a>Pluggable Storage Engines：存储引擎</h2><p>与其他数据库例如Oracle 和SQL Server等数据库中只有一种存储引擎不同的是，MySQL有一个被称为“PluggableStorage Engine Architecture”(可插拔的存储引擎架构)的特性，也就意味着MySQL数据库提供了多种存储引擎。<br>而且存储引擎是针对表的，用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。也就是说，同一数据库不同的表可以选择不同的存储引擎</p><h2 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h2><ul><li><strong>MySQL存储引擎类型</strong></li></ul><table><thead><tr><th>存储引擎</th><th>说明</th></tr></thead><tbody><tr><td><strong>MyISAM</strong></td><td>高速引擎，拥有较高的插入，查询速度，<strong>但不支持事务</strong></td></tr><tr><td><strong>InnoDB</strong></td><td><strong>5.5版本后MySQL的默认数据库，支持事务、行级锁、表级锁</strong>，比MyISAM处理速度稍慢</td></tr><tr><td>ISAM</td><td>MyISAM的前身，MySQL5.0以后不再默认安装</td></tr><tr><td>MRG_MyISAM(MERGE)</td><td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td></tr><tr><td>Memory</td><td><strong>内存存储引擎，拥有极高的插入，更新和查询效率。</strong>但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失</td></tr><tr><td>Falcon</td><td>一种新的存储引擎，支持事务处理，传言可能是innoDB的替代者</td></tr><tr><td>Archive</td><td>将数据压缩后进行存储，非常适合存储大量的独立的历史记录数据，但是只能进行插入和查询操作</td></tr><tr><td>CSV</td><td>CSV存储引擎是基于CSV格式文件存储数据（应用于跨平台的数据交换）</td></tr></tbody></table><ul><li><strong>MyISAM和InnoDB存储引擎的区别</strong></li></ul><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td><strong>存储文件</strong></td><td>.frm 表定义文件 <br><strong>.ibd 数据文件和索引文件</strong></td><td>.frm 表定义文件 <br><strong>.MYD 数据文件 <br>.MYI 索引文件</strong></td></tr><tr><td><strong>存储限制</strong></td><td>64TB</td><td>无</td></tr><tr><td><strong>锁</strong></td><td><strong>行锁</strong>、表锁</td><td>表锁</td></tr><tr><td><strong>事务</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>CRUD</strong></td><td>读、写</td><td>读</td></tr><tr><td><strong>count</strong></td><td>扫表</td><td>专门存储的地方</td></tr><tr><td><strong>支持外键</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>索引结构</strong></td><td>B+ Tree</td><td>B+ Tree</td></tr></tbody></table><h2 id="简版执行流程图"><a href="#简版执行流程图" class="headerlink" title="简版执行流程图"></a>简版执行流程图</h2><p><img src="2.jpg" alt="简版执行流程图"></p><h2 id="详细执行流程图"><a href="#详细执行流程图" class="headerlink" title="详细执行流程图"></a>详细执行流程图</h2><p><img src="3.jpg" alt="详细执行流程图"></p><h2 id="物理文件"><a href="#物理文件" class="headerlink" title="物理文件"></a>物理文件</h2><h2 id="日志文件（顺序IO）"><a href="#日志文件（顺序IO）" class="headerlink" title="日志文件（顺序IO）"></a>日志文件（顺序IO）</h2><p>MySQL通过日志记录了数据库操作信息和错误信息。常用的日志文件包括<strong>错误日志、二进制日志、查询日志、慢查询日志、事务Redo日志、中继日志</strong>等。</p><h3 id="错误日志（errorlog）"><a href="#错误日志（errorlog）" class="headerlink" title="错误日志（errorlog）"></a>错误日志（errorlog）</h3><p>默认是开启的，而且从5.5.7以后无法关闭错误日志，错误日志记录了运行过程中<strong>遇到的所有严重的错误信息</strong>，以及MySQL每次启动和关闭的详细信息。</p><h3 id="二进制日志（bin-log）"><a href="#二进制日志（bin-log）" class="headerlink" title="二进制日志（bin log）"></a>二进制日志（bin log）</h3><p>默认是关闭的，binlog记录了数据库所有的ddl语句和dml语句，但不包括<strong>select</strong>语句内容，语句以时间的形式保存，描述了数据的变更顺序，binlog还包括了每个更新语句的执行时间信息。如果是DDL语句，则直接记录到binlog日志，而DML语句，必须通过<strong>事务提交</strong>才能记录到binlog日志中。</p><p>binlog主要用户实现mysql<strong>主从复制</strong>、<strong>数据备份</strong>、<strong>数据恢复</strong>、<strong>数据监听</strong>。</p><h3 id="通用查询日志（general-query-log）"><a href="#通用查询日志（general-query-log）" class="headerlink" title="通用查询日志（general query log）"></a>通用查询日志（general query log）</h3><p>默认情况下通用查询日志是关闭的。查询日志记录客户端的所有语句（所有连接和语句都记录到通用日志）。</p><h3 id="慢查询日志（slow-query-log）"><a href="#慢查询日志（slow-query-log）" class="headerlink" title="慢查询日志（slow query log）"></a>慢查询日志（slow query log）</h3><p>慢查询日志记录了所有执行时间超过参数long_query_time设置值并且扫描记录数不小于min_examined_row_limit的所有SQL语句的日志（获得表锁定的时间不能算作执行时间）。</p><ul><li><p>show_query_log：参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。</p></li><li><p>long_query_time：默认是10秒，最小为0，精度可以到微妙</p></li><li><p>min_examined_row_limit：查询检查返回少于该参数指定行的SQL不被记录到慢查询日志</p></li></ul><h3 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h3><ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li></ul><h3 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3><p>保存了事务发生之前数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），即非锁定读。</p><h3 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h3><ul><li>是在主从复制环境中产生的日志。</li><li>主要作用是为了从机可以从中继日志中获取到主机同步过来的SQL语句，然后执行到从机中。</li></ul><h2 id="数据文件（随机IO）"><a href="#数据文件（随机IO）" class="headerlink" title="数据文件（随机IO）"></a>数据文件（随机IO）</h2><h4 id="InnoDB数据文件"><a href="#InnoDB数据文件" class="headerlink" title="InnoDB数据文件"></a>InnoDB数据文件</h4><ul><li>.frm文件：主要存放于表相关的数据信息，主要包括表结构的定义信息。</li><li>.ibd文件：使用独享表空间存储表数据和索引信息，一张表对应一个ibd文件。</li><li>ibdata文件：使用共享表空间存储表数据、索引和缓存信息，所有表共同使用一个或者多个ibdata文件。</li></ul><h4 id="MyISAM数据文件"><a href="#MyISAM数据文件" class="headerlink" title="MyISAM数据文件"></a>MyISAM数据文件</h4><ul><li>.frm文件：主要存放于表相关的数据信息，主要包括表结构的定义信息。</li><li>.myd文件：主要用来存储表数据信息。</li><li>.myi文件：主要用来存储表数据文件中任何索引的数据树。</li></ul><h1 id="MySQL性能分析"><a href="#MySQL性能分析" class="headerlink" title="MySQL性能分析"></a>MySQL性能分析</h1><ul><li>通过观察查询慢日志，确定具体哪些SQL比较慢（功能默认是关闭，需要手动开启）</li><li>通过explain和慢SQL分析</li><li>通过show profile查看慢SQL执行的性能情况，包括CPU、IO、执行SQL锁消耗的时间等。该工具在5.0.37以及以上版本中才能使用（功能默认是关闭，需要手动开启）</li></ul><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><ul><li>索引可以大大提高MySQL的检索速度</li><li>使用B+树结构（多路搜索树，并不一定是二叉）</li><li>索引是存储在磁盘文件中的（可能在单独的索引文件，也可能和数据存在一起）</li></ul><h3 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序的临时表</li><li>索引可以将随机I/O变成顺序IO</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>索引需要占用磁盘空间</li><li>索引在更新表时会降低效率，新增、修改、删除</li></ul><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>多表关联查询中，关联字段应该创建索引 on 两边都要创建索引</li><li>查询中排序的字段，应该创建索引</li><li>频繁查找字段 覆盖索引</li><li>查询中统计或者分组字段，应该创建索引 group by</li></ul><h3 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h3><ul><li>表记录太少</li><li>经常进行增删改操作的表</li><li>频繁更新的字段</li><li>where条件里使用频率不高的字段</li></ul><h3 id="为什么使用组合索引"><a href="#为什么使用组合索引" class="headerlink" title="为什么使用组合索引"></a>为什么使用组合索引</h3><p>mysql创建组合索引的规则是首先会对组合索引的最左边的，也就是第一个a字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的b字段进行排序。其实就相当于实现了类似 order by a b这样一种排序规则。</p><p><strong>为了节省mysql索引存储空间以及提升搜索性能</strong>，可建立组合索引（能使用组合索引就不使用单列索引）</p><p>例如：<br>创建组合索引（相当于建立了col1,col1 col2,col1 col2 col3三个索引）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)</span><br></pre></td></tr></table></figure><h2 id="常用索引分类"><a href="#常用索引分类" class="headerlink" title="常用索引分类"></a>常用索引分类</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><ul><li>这是最基本的索引，它没有任何限制</li></ul><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><ul><li>这种索引和普通索引基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一，允许为空</li><li>主键索引（PRIMARY KEY）是一种特殊的唯一索引，创建类型推荐使用int类型</li><li>建表时未设置主键索引，mysql会默认新建6byte空间的自动增长主键，可以用select _rowid from table来查询</li></ul><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><ul><li>在表中的多个字段组合成一个索引</li><li>建议使用组合索引代替单列索引</li><li>组合索引需要遵循最左原则</li></ul><h3 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h3><h4 id="索引存储结构介绍"><a href="#索引存储结构介绍" class="headerlink" title="索引存储结构介绍"></a>索引存储结构介绍</h4><ul><li>索引是在存储引擎中实现的。</li><li>MyISAM和InnoDB存储引擎：只支持BTREE索引，也就是默认使用BTREE，不能修改</li></ul><h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>数据结构示例网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><h5 id="B树示图"><a href="#B树示图" class="headerlink" title="B树示图"></a>B树示图</h5><ul><li>B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树。 多叉平衡</li><li>B树的高度一般都是在2-4这个高度，树的高度直接影响IO读写的次数，以及查询时间复杂度(log(n))</li><li>如果是三层树结构—支撑的数据可以达到20G，如果是四层树结构—支撑的数据可以达到几十T</li></ul><p><img src="4.jpg" alt="B树"></p><h5 id="B-树示图"><a href="#B-树示图" class="headerlink" title="B+树示图"></a>B+树示图</h5><p><img src="5.jpg" alt="B+树"></p><h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><p>B树和B+树的最大区别在于非叶子节点是否存储数据的问题。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- B树是非叶子节点和叶子节点都会存储数据,存放数据地址</span><br><span class="line">- B+树只有叶子节点才会存储数据，而且存储的数据都是在一行上，而且这些数据都是有指针指向的，也就是有顺序的。</span><br><span class="line">索引列 order by id会使用到主键索引</span><br></pre></td></tr></table></figure><h5 id="非聚集索引（MyISAM）"><a href="#非聚集索引（MyISAM）" class="headerlink" title="非聚集索引（MyISAM）"></a>非聚集索引（MyISAM）</h5><ul><li>B+树叶子节点只会存储数据行（数据文件）的指针，<strong>简单来说数据和索引不在一起，就是非聚集索引</strong>。</li><li>非聚集索引包含主键索引和辅助索引都会存储指针的值</li></ul><h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p><img src="6.png" alt="主键索引"></p><p>这里设表一共有三列,假设我们以 Col1 为主键,则上图是一个 MyISAM 表的主索引(Primary key)示意。可以看出<br>MyISAM 的索引文件仅仅保存数据记录的地址。</p><h6 id="辅助索引（次要索引）"><a href="#辅助索引（次要索引）" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h6><p>在 MyISAM 中,主索引和辅助索引(Secondary key)在结构上没有任何区别,只是主索引要求 key 是唯一的,而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引,则此索引的结构如下图所示</p><p><img src="7.png" alt="辅助索引"></p><h5 id="聚集索引（InnoDB）"><a href="#聚集索引（InnoDB）" class="headerlink" title="聚集索引（InnoDB）"></a>聚集索引（InnoDB）</h5><ul><li>主键索引（聚集索引）的叶子节点会存储数据行，<strong>也就是说数据和索引是在一起，这就是聚集索引</strong></li><li>辅助索引只会存储主键值</li><li>如果没有没有主键，则使用唯一索引建立聚集索引；如果没有唯一索引，MySQL会按照一定规则创建聚集索<br>引</li></ul><h6 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h6><ul><li>InnoDB 要求表必须有主键(MyISAM 可以没有),如果没有显式指定,则 MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键,如果不存在这种列,则MySQL 自动为 InnoDB 表生成一个隐含字段作为主键,类型为长整形。</li></ul><p><img src="8.png" alt="主键索引"></p><ul><li>上图是 InnoDB 主索引(同时也是数据文件)的示意图,可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集,</li></ul><h6 id="辅助索引（次要索引）-1"><a href="#辅助索引（次要索引）-1" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h6><ul><li><p>第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话<br>说,InnoDB 的所有辅助索引都引用主键作为 data 域。</p><p><img src="9.png" alt="辅助索引"></p></li><li><p>聚集索引这种实现方式使得按主键的搜索十分高效,但是辅助索引搜索需要检索两遍索引:首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span> <span class="comment">##回表 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span> <span class="comment">##覆盖索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, age,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Alice'</span> <span class="comment">##覆盖索引</span></span><br></pre></td></tr></table></figure><h2 id="索引覆盖与回表查询"><a href="#索引覆盖与回表查询" class="headerlink" title="索引覆盖与回表查询"></a>索引覆盖与回表查询</h2><p><img src="10.jpg" alt></p><ul><li>索引覆盖是指返回的列在针对辅助索引树上都存在，name,age形成组合索引，查询返回的列id,name,age都在索引树上，不需要再次回表查询主键索引树就能返回查询数据</li><li>回表是指查询条件非主键索引，通过辅助索引去查询数据，无法在辅助索引列上一次获取到所有需要的列字段，通过辅助索引查询获取到值（主键索引ID）再去查询主键索引树来获取返回列数据</li></ul><fron><p><br><br></p></fron><p></p><p>【参考链接】</p><p><a href="https://blog.csdn.net/zwjyyy1203/article/details/80664545" target="_blank" rel="noopener">https://blog.csdn.net/zwjyyy1203/article/details/80664545</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务注册中心 Eureka 架构深入解读（转载）</title>
      <link href="/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka-%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/"/>
      <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka-%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>微服务架构中最核心的部分是服务治理，服务治理最基础的组件是注册中心。随着微服务架构的发展，出现了很多微服务架构的解决方案，其中包括我们熟知的 Dubbo 和 Spring Cloud。</p><p>关于注册中心的解决方案，dubbo 支持了 Zookeeper、Redis、Multicast 和 Simple，官方推荐 Zookeeper。Spring Cloud 支持了 Zookeeper、Consul 和 Eureka，官方推荐 Eureka。</p><a id="more"></a><p>两者之所以推荐不同的实现方式，原因在于组件的特点以及适用场景不同。简单来说：</p><ul><li><p>ZK 的设计原则是 CP，即强一致性和分区容错性。他保证数据的强一致性，但舍弃了可用性，<strong>如果出现网络问题可能会影响 ZK 的选举，导致 ZK 注册中心的不可用</strong>。</p></li><li><p>Eureka 的设计原则是 AP，即可用性和分区容错性。他保证了注册中心的可用性，但舍弃了数据一致性，<strong>各节点上的数据有可能是不一致的（会最终一致）</strong>。</p><p>Eureka 采用纯 Java 实现，除实现了注册中心基本的服务注册和发现之外，极大的满足注册中心的可用性，即使只有一台服务可用，也可以保证注册中心的可用性。</p></li></ul><p>本文将聚焦到 Eureka 的内部实现原理，先从微服务架构的部署图介绍 Eureka 的总体架构，然后剖析服务信息的存储结构，最后探究跟服务生命周期相关的服务注册机制、服务续约机制、服务注销机制、服务剔除机制、服务获取机制、和服务同步机制。</p><h2 id="Eureka-总体架构"><a href="#Eureka-总体架构" class="headerlink" title="Eureka 总体架构"></a>Eureka 总体架构</h2><p>下面是 Eureka 注册中心部署在多个机房的架构图，这正是他高可用性的优势（Zookeeper 千万别这么部署）。</p><p><img src="1.png" alt></p><p>从组件功能看：</p><ul><li>黄色注册中心集群，分别部署在北京、天津、青岛机房；</li><li>红色服务提供者，分别部署北京和青岛机房；</li><li>淡绿色服务消费者，分别部署在北京和天津机房；</li></ul><p>从机房分布看：</p><ul><li>北京机房部署了注册中心、服务提供者和服务消费者；</li><li>天津机房部署了注册中心和服务消费者；</li><li>青岛机房部署了注册中心和服务提供者；</li></ul><h3 id="组件调用关系"><a href="#组件调用关系" class="headerlink" title="组件调用关系"></a>组件调用关系</h3><p><strong>服务提供者</strong></p><ol><li>启动后，向注册中心发起 register 请求，注册服务</li><li>在运行过程中，定时向注册中心发送 renew 心跳，证明“我还活着”。</li><li>停止服务提供者，向注册中心发起 cancel 请求，清空当前服务注册信息。</li></ol><p><strong>服务消费者</strong></p><ol><li>启动后，从注册中心拉取服务注册信息</li><li>在运行过程中，定时更新服务注册信息。</li><li>服务消费者发起远程调用：<br>a&gt; 服务消费者（北京）会从服务注册信息中选择同机房的服务提供者（北京），发起远程调用。只有同机房的服务提供者挂了才会选择其他机房的服务提供者（青岛）。<br>b&gt; 服务消费者（天津）因为同机房内没有服务提供者，则会按负载均衡算法选择北京或青岛的服务提供者，发起远程调用。</li></ol><p><strong>注册中心</strong></p><ol><li><p>启动后，从其他节点拉取服务注册信息。</p></li><li><p>运行过程中，定时运行 evict 任务，剔除没有按时 renew 的服务（包括非正常停止和网络故障的服务）。</p></li><li><p>运行过程中，接收到的 register、renew、cancel 请求，都会同步至其他注册中心节点。</p><p>本文将详细说明上图中的 registry、register、renew、cancel、getRegistry、evict 的内部机制。</p></li></ol><h2 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h2><p>既然是服务注册中心，必然要存储服务的信息，我们知道 ZK 是将服务信息保存在树形节点上。而下面是 Eureka 的数据存储结构：</p><p><img src="2.png" alt></p><p>Eureka 的数据存储分了两层：数据存储层和缓存层。</p><p>Eureka Client 在拉取服务信息时，先从缓存层获取（相当于 Redis），如果获取不到，先把数据存储层的数据加载到缓存中（相当于 Mysql），再从缓存中获取。值得注意的是，数据存储层的数据结构是服务信息，而缓存中保存的是经过处理加工过的、可以直接传输到 Eureka Client 的数据结构。</p><p>Eureka 这样的数据结构设计是把内部的数据存储结构与对外的数据结构隔离开了，就像是我们平时在进行接口设计一样，对外输出的数据结构和数据库中的数据结构往往都是不一样的。</p><p><strong>数据存储层</strong></p><p>这里为什么说是存储层而不是持久层？因为 rigistry 本质上是一个双层的 ConcurrentHashMap，存储在内存中的。</p><ul><li><p>第一层的 key 是<code>spring.application.name</code>，value 是第二层 ConcurrentHashMap；</p></li><li><p>第二层 ConcurrentHashMap 的 key 是服务的 InstanceId，value 是 Lease 对象；</p></li><li><p>Lease 对象包含了服务详情和服务治理相关的属性。</p><p><strong>二级缓存层</strong></p></li></ul><p>Eureka 实现了二级缓存来保存即将要对外传输的服务信息，数据结构完全相同。</p><ul><li>一级缓存：<code>ConcurrentHashMap&lt;Key,Value&gt; readOnlyCacheMap</code>，本质上是 HashMap，无过期时间，保存服务信息的对外输出数据结构。</li><li>二级缓存：<code>Loading&lt;Key,Value&gt; readWriteCacheMap</code>，本质上是 guava 的缓存，包含失效机制，保存服务信息的对外输出数据结构。</li></ul><p>既然是缓存，那必然要有更新机制，来保证数据的一致性。下面是缓存的更新机制：</p><p><img src="3.png" alt></p><p>更新机制包含删除和加载两个部分，上图黑色箭头表示删除缓存的动作，绿色表示加载或触发加载的动作。</p><p><strong>删除二级缓存：</strong></p><ol><li>Eureka Client 发送 register、renew 和 cancel 请求并更新 registry 注册表之后，删除二级缓存；</li><li>Eureka Server 自身的 Evict Task 剔除服务后，删除二级缓存；</li><li>二级缓存本身设置了 guava 的失效机制，隔一段时间后自己自动失效；</li></ol><p><strong>加载二级缓存：</strong></p><ol><li>Eureka Client 发送 getRegistry 请求后，如果二级缓存中没有，就触发 guava 的 load，即从 registry 中获取原始服务信息后进行处理加工，再加载到二级缓存中。</li><li>Eureka Server 更新一级缓存的时候，如果二级缓存没有数据，也会触发 guava 的 load。</li></ol><p><strong>更新一级缓存：</strong></p><ol><li><p>Eureka Server 内置了一个 TimerTask，定时将二级缓存中的数据同步到一级缓存（这个动作包括了删除和加载）。</p><p>关于缓存的实现参考 ResponseCacheImpl</p></li></ol><h3 id="服务注册机制"><a href="#服务注册机制" class="headerlink" title="服务注册机制"></a>服务注册机制</h3><p>服务提供者、服务消费者、以及服务注册中心自己，启动后都会向注册中心注册服务（如果配置了注册）。下图是介绍如何完成服务注册的：</p><p><img src="4.png" alt></p><p>注册中心服务接收到 register 请求后：</p><ol><li>保存服务信息，将服务信息保存到 registry 中；</li><li>更新队列，将此事件添加到更新队列中，供 Eureka Client 增量同步服务信息使用。</li><li>清空二级缓存，即 readWriteCacheMap，用于保证数据的一致性。</li><li>更新阈值，供剔除服务使用。</li><li>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</li></ol><h3 id="服务续约机制"><a href="#服务续约机制" class="headerlink" title="服务续约机制"></a>服务续约机制</h3><p>服务注册后，要定时（默认 30S，可自己配置）向注册中心发送续约请求，告诉注册中心“我还活着”。</p><p><img src="5.png" alt></p><p>注册中心收到续约请求后：</p><ol><li><p>更新服务对象的最近续约时间，即 Lease 对象的 lastUpdateTimestamp;</p></li><li><p>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</p><p>剔除服务之前会先判断服务是否已经过期，判断服务是否过期的条件之一是续约时间和当前时间的差值是不是大于阈值。</p></li></ol><h3 id="服务注销机制"><a href="#服务注销机制" class="headerlink" title="服务注销机制"></a>服务注销机制</h3><p>服务<strong>正常停止</strong>之前会向注册中心发送注销请求，告诉注册中心“我要下线了”。</p><p><img src="6.png" alt></p><p>注册中心服务接收到 cancel 请求后：</p><ol><li><p>删除服务信息，将服务信息从 registry 中删除；</p></li><li><p>更新队列，将此事件添加到更新队列中，供 Eureka Client 增量同步服务信息使用。</p></li><li><p>清空二级缓存，即 readWriteCacheMap，用于保证数据的一致性。</p></li><li><p>更新阈值，供剔除服务使用。</p></li><li><p>同步服务信息，将此事件同步至其他的 Eureka Server 节点。</p><p>服务正常停止才会发送 Cancel，如果是非正常停止，则不会发送，此服务由 Eureka Server 主动剔除。</p></li></ol><h3 id="服务剔除机制"><a href="#服务剔除机制" class="headerlink" title="服务剔除机制"></a>服务剔除机制</h3><p>Eureka Server 提供了服务剔除的机制，用于剔除没有正常下线的服务。</p><p><img src="7.png" alt></p><p>服务的剔除包括三个步骤，首先判断是否满足服务剔除的条件，然后找出过期的服务，最后执行剔除。</p><p><strong>判断是否满足服务剔除的条件</strong></p><p>有两种情况可以满足服务剔除的条件：</p><ol><li>关闭了自我保护</li><li>如果开启了自我保护，需要进一步判断是 Eureka Server 出了问题，还是 Eureka Client 出了问题，如果是 Eureka Client 出了问题则进行剔除。</li></ol><p>这里比较核心的条件是自我保护机制，Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。Eureka 的自我保护机制“谦虚”的认为如果大量服务都续约失败，则认为是自己出问题了（如自己断网了），也就不剔除了；反之，则是 Eureka Client 的问题，需要进行剔除。而<strong>自我保护阈值是区分 Eureka Client 还是 Eureka Server 出问题的临界值：如果超出阈值就表示大量服务可用，少量服务不可用，则判定是 Eureka Client 出了问题。如果未超出阈值就表示大量服务不可用，则判定是 Eureka Server 出了问题</strong>。</p><p>条件 1 中如果关闭了自我保护，则统统认为是 Eureka Client 的问题，把没按时续约的服务都剔除掉（这里有剔除的最大值限制）。</p><p>这里比较难理解的是阈值的计算：</p><ul><li>自我保护阈值 = 服务总数 * 每分钟续约数 * 自我保护阈值因子。</li><li>每分钟续约数 =（60S/ 客户端续约间隔）</li></ul><p>最后自我保护阈值的计算公式为：</p><p>自我保护阈值 = 服务总数 * （60S/ 客户端续约间隔） * 自我保护阈值因子。</p><p><strong>举例</strong>：如果有 100 个服务，续约间隔是 30S，自我保护阈值 0.85。</p><p>自我保护阈值 =100 * 60 / 30 * 0.85 = 170。</p><p>如果上一分钟的续约数 =180&gt;170，则说明大量服务可用，是服务问题，进入剔除流程；</p><p>如果上一分钟的续约数 =150&lt;170，则说明大量服务不可用，是注册中心自己的问题，进入自我保护模式，不进入剔除流程。</p><p><strong>找出过期的服务</strong></p><p>遍历所有的服务，判断上次续约时间距离当前时间大于阈值就标记为过期。并将这些过期的服务保存到集合中。</p><p><strong>剔除服务</strong></p><p>在剔除服务之前先计算剔除的数量，然后遍历过期服务，通过洗牌算法确保每次都公平的选择出要剔除的任务，最后进行剔除。</p><p>执行剔除服务后：</p><ol><li><p>删除服务信息，从 registry 中删除服务。</p></li><li><p>更新队列，将当前剔除事件保存到更新队列中。</p></li><li><p>清空二级缓存，保证数据的一致性。</p><p>实现过程参考 AbstractInstanceRegistry.evict() 方法。</p></li></ol><h3 id="服务获取机制"><a href="#服务获取机制" class="headerlink" title="服务获取机制"></a>服务获取机制</h3><p>Eureka Client 获取服务有两种方式，全量同步和增量同步。获取流程是根据 Eureka Server 的多层数据结构进行的：</p><p><img src="8.png" alt></p><p>无论是全量同步还是增量同步，都是先从缓存中获取，如果缓存中没有，则<strong>先加载到缓存中，再从缓存中获取。（registry 只保存数据结构，缓存中保存 ready 的服务信息。）</strong></p><ol><li>先从一级缓存中获取<br>a&gt; 先判断是否开启了一级缓存<br>b&gt; 如果开启了则从一级缓存中获取，如果存在则返回，如果没有，则从二级缓存中获取<br>d&gt; 如果未开启，则跳过一级缓存，从二级缓存中获取</li><li>再从二级缓存中获取<br>a&gt; 如果二级缓存中存在，则直接返回；<br>b&gt; 如果二级缓存中不存在，则先将数据加载到二级缓存中，再从二级缓存中获取。注意加载时需要判断是增量同步还是全量同步，增量同步从 recentlyChangedQueue 中 load，全量同步从 registry 中 load。</li></ol><h3 id="服务同步机制"><a href="#服务同步机制" class="headerlink" title="服务同步机制"></a>服务同步机制</h3><p>服务同步机制是用来同步 Eureka Server 节点之间服务信息的。它包括 Eureka Server 启动时的同步，和运行过程中的同步。</p><p><strong>启动时同步</strong></p><p><img src="9.png" alt></p><p>Eureka Server 启动后，遍历 eurekaClient.getApplications 获取服务信息，并将服务信息注册到自己的 registry 中。</p><p>注意这里是两层循环，第一层循环是为了保证已经拉取到服务信息，第二层循环是遍历拉取到的服务信息。</p><p><strong>运行过程中同步</strong></p><p><img src="10.png" alt></p><p>当 Eureka Server 节点有 register、renew、cancel 请求进来时，会将这个请求封装成 TaskHolder 放到 acceptorQueue 队列中，然后经过一系列的处理，放到 batchWorkQueue 中。</p><p><code>TaskExecutor.BatchWorkerRunnable</code>是个线程池，不断的从 batchWorkQueue 队列中 poll 出 TaskHolder，然后向其他 Eureka Server 节点发送同步请求。</p><p>这里省略了两个部分：</p><ul><li>一个是在 acceptorQueue 向 batchWorkQueue 转化时，省略了中间的 processingOrder 和 pendingTasks 过程。</li><li>另一个是当同步失败时，会将失败的 TaskHolder 保存到 reprocessQueue 中，重试处理。</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对微服务解决方案 Dubbo 和 Spring Cloud 的对比非常多，这里对注册中心做个简单对比。</p><p><img src="11.png" alt></p><table><thead><tr><th align="left"></th><th align="left">Zookeeper</th><th align="left">Eureka</th></tr></thead><tbody><tr><td align="left">设计原则</td><td align="left">CP</td><td align="left">AP</td></tr><tr><td align="left">优点</td><td align="left">数据强一致</td><td align="left">服务高可用</td></tr><tr><td align="left">缺点</td><td align="left">网络分区会影响 Leader 选举，超过阈值后集群不可用</td><td align="left">服务节点间的数据可能不一致； Client-Server 间的数据可能不一致；</td></tr><tr><td align="left">适用场景</td><td align="left">单机房集群，对数据一致性要求较高</td><td align="left">云机房集群，跨越多机房部署；对注册中心服务可用性要求较高</td></tr></tbody></table><p>[转载链接]</p><p><a href="https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh" target="_blank" rel="noopener">https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList与LinkedList</title>
      <link href="/ArrayList%E4%B8%8ELinkedList/"/>
      <url>/ArrayList%E4%B8%8ELinkedList/</url>
      
        <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>以下是数组在内存中存储结构和扩容过程。</p><p>array数组长度为4，现在需要放入第五个值，需要先扩容，在后边找到能容下新数组长度的连续空间</p><a id="more"></a><p><img src="2.1.png" alt></p><ul><li><p>新增数据空间判断</p><p>新增数据的时候需要判断当前是否有空闲空间存储数据</p></li><li><p>扩容需要申请新的连续空闲空间</p><p>上图为例，长度4需要扩容到8。必须找到长度为8的连续空间才能新建扩容数组</p></li><li><p>把老的数组复制过去，追加新的内容</p></li><li><p>回收老的数组空间</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><img src="2.2.png" alt></p><ul><li>寻找一个元素空间插入即可，不需要连续空间</li><li>链表长度大小不定</li><li>需要寻址，节省空间</li></ul><h3 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h3><p><img src="3.png" alt></p><ul><li><p>O(1)就是最低的时空复杂度了，耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 <strong>哈希算法就是典型的O(1)时间复杂度</strong>，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</p></li><li><p>O(N)就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法，就是O(n)；</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ArrayList是由数组组成，大小固定，不适合动态存储，LinkedList由双向列表组成，大小可变，扩展性强；ArrayList扩容大小为1.5倍(newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1))</li><li>ArrayList查询和修改方便，只需要修改和获取指定的数组值，LinkedList新增和删除方便，因为只需要添加和删除节点</li><li>数据结构都是存储在内存中，一般初始化时指定大小都是2的倍数，计算机分配空间都是使用次幂去分配，好处是能减少碎片空间，ArrayList扩容时需要查询连续的空间，而LinkedList只需要查询到下一个空间即可</li><li>同样是O(N)次遍历，ArrayList快于LinkedList，因为CPU缓存一次读取多块，ArrayList获取空间块链是连续的，而Linked获取空间块链可能是跳跃的，获取下一个元素需要利用内存中的下标去查找，CPU缓存读取速度大于内存</li><li>forEach循环时删除元素会爆ConcurrentModificationException异常,要使用迭代器(Iterator),或者线程安全的集合,原因是java.util.ArrayList.Itr#checkForComodification方法中modCount != expectedModCount</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核空间和用户空间</title>
      <link href="/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
      <url>/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="Rings"><a href="#Rings" class="headerlink" title="Rings"></a>Rings</h3><p>在计算机科学中, <strong>分级保护域</strong>（英语：hierarchical protection domains），经常被叫作<strong>保护环</strong>（Protection Rings），又称<strong>环型保护</strong>（Rings Protection）、<strong>CPU环</strong>（CPU Rings），简称Rings。这是一种用来在发生故障时保护数据和功能，提升容错度，避免恶意操作 ，提升计算机安全的设计方式。</p><a id="more"></a><p>（来自维基百科）</p><p><img src="1.png" alt></p><p>工作在不同Ring中的对象对资源有不同的访问级别。Rings是从最高特权级（通常对应最小的数字）到最低特权级（最大的数字）排列的。在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），同时内层Ring可以随便使用外层Ring的资源。</p><ul><li>Ring 0用于内核代码和驱动程序</li><li>Ring 1-2用于设备驱动程序</li><li>Ring 3用于非特权代码（几乎所有的用户程序都在这一级别）</li></ul><p>​          Rings的概念最早出现于x 86保护模式的设计中。Intel的初衷是让驱动存在于此Ring 1-2，但现代操作系统通常将驱动也放在Ring 0上。</p><h3 id="内核空间（Kernel-space-）与用户空间（User-space-）"><a href="#内核空间（Kernel-space-）与用户空间（User-space-）" class="headerlink" title="内核空间（Kernel space ）与用户空间（User space ）"></a>内核空间（Kernel space ）与用户空间（User space ）</h3><p>Kernel space 是 Linux 内核的运行空间（Ring0），User space 是用户程序的运行空间（Ring3）。通过分环隔离实现了操作系统的稳定性及可用性，即使用户的程序崩溃了，内核也不受影响。</p><p>下面描述用户空间与内核空间交互情况（来自互联网）：</p><p><img src="2.png" alt></p><p>运行在Kernel space的进程拥有CPU环最高权限，可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（system call），才能向内核发出指令。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = "my string" // 用户空间</span><br><span class="line">x = x + 2</span><br><span class="line">file.write(str) // 切换到内核空间</span><br><span class="line"></span><br><span class="line">y = x + 4 // 切换回用户空间</span><br></pre></td></tr></table></figure><p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p><h3 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h3><p>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为<strong>内核空间</strong>。而较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为<strong>用户空间</strong>。当进程运行在Ring0级别时被称为运行在<strong>内核态</strong>，而运行在Ring3级别时被称为<strong>用户态</strong>。</p><p>下面描述了每个进程寻址空间的分配情况（来自互联网）:</p><p><img src="3.png" alt></p><p><font color="#FF0000"><strong>内核空间是所有进程共享，用户空间是当前进程独享</strong></font></p><p>内核空间中存放的是<strong>内核代码</strong>和<strong>数据</strong>，而进程的用户空间中存放的是<strong>用户程序的代码</strong>和<strong>数据</strong>。不管是内核空间还是用户空间，它们都处于虚拟空间中。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>通过用户空间和内核空间的角度看一看Linux系统的架构(此图来自互联网)：</p><p><img src="4.png" alt></p><ul><li><p>当用户空间运行进程需要使用硬件资源或设备驱动时，通过调用内核空间暴露的接口（System Call）来申请资源或写入内核空间的高速页缓存</p></li><li><p>内核空间进程会实时调用（fsync）或由操作系统统一调度flusher内核线程将（write）数据同步到磁盘</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以Mysql为例：</span><br><span class="line">innodb_flush_log_at_trx_commit 1 (fsync)</span><br><span class="line">事务提交时，进程会将数据写入用户空间应用缓存,同时掉用系统提供fsync函数将用户空间缓存的数据写入磁盘</span><br><span class="line">innodb_flush_log_at_trx_commit 2 (write)</span><br><span class="line">事务提交时，进程会调用systemCall函数将用户空间应用缓存数据通过dma的方式copy到内核空间高速页缓存,等待flusher内核线程将数据写入磁盘</span><br></pre></td></tr></table></figure><p>从架构图可以看出内核空间进程可以操作设备程序（网卡程序、显卡程序）和硬件设备（键盘、鼠标、音箱）</p></li></ul><fron><p><br><br></p></fron><p></p><p>[参考链接]</p><ul><li><a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/8410350.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
